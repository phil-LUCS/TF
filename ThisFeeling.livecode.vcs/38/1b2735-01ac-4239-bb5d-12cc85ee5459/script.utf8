constant cNumEmotions = 9
constant cEmotScaleFactorItem = 10

constant cViewList = "FrontAndBack,hands,feet,head_back,head_front"

constant cFaded = 65
constant cFullOn = 15

constant cHostServer = "cgi.csc.liv.ac.uk"

constant cDebugLevel = "full"
--constant cDebugLevel = "normal"

global gUUID --used to identify any data generated by the app. Note - this is created on first run and will only be re-created if the app is deleted and reinstalled
global gToMove, gCurrentEmotion
global gGender
global gShowWhichSingleBodyView
global gCurrentView
global gTextTouchInProgress --in here we put the name of the editable field we touched and the ID of the touch that started things...
global gTextEditTarget
global gKeyboardOnShow
global gEmotPaletteStatus
global gEmotPaletteConfig
global gInitialTextTouchLoc
global gTouchToEditText --if this preference is true, we only need to tap a text box to edit it, rather than hold down on it for a period of time.


global gShowZoomPalette
global gShowTwoViews
global gUseVandPImages
global gEnableGremlinMode
global gShowFireObject
global gShowNoPainObject
global gEnableColourSwatches
global gShowLRGuidance

global gPrefs


global gSessionFolder --where do we save stuff?

global gPageCount
global gCurrentPage
global gBackdropTouchDown

global gDrawingPageArr
global gScaledDrawingPageArr
global gPainSpotPageArr
global gPageDescArr
global gPageEmotionArr
global gPageDirtyFlagArr
global gViewWidthsArr

global gEmotionLabelsArr

constant cFirstRunFlagFile = "TF_FRFF.txt"
constant cPreferencesFile = "TF_Prefs.txt"


on preOpenStack
   InitStack
   RedrawBackdrop
   put 1 into gCurrentPage
   put "FrontAndBack" into gCurrentView
end preOpenStack


on InitStack
   put "male" into gGender --the default
   put "front" into gShowWhichSingleBodyView
   put "compact" into gEmotPaletteConfig
   
   CheckForFirstRun
   
   LoadStoredPrefs --won't load anything if it can't find a saved prefs file.
   ResetEPStatus
   SetupPersonImages --for The Emotions card & the Somatic Card
   ResetSomaticCard
   
   --   if mob() then
   --      StartNetworkCheck
   --   end if
end InitStack


--
-- Resets the Somatic Card and clears any pain spots and drawings. Also clears the emotion.
-- Checks to see if there are any pain spots and drawings to clear before attempting to do so.
--
on ResetSomaticCard
   global gCurrentPainSpot
   global gMostRecentScreenShotArr
   if (the number of lines of the keys of gPainSpotPageArr[gCurrentPage][gCurrentView] > 0) or ( the number of lines of the keys of gDrawingPageArr[gCurrentPage][gCurrentView] > 0) then
      send ClearCurrentPage && "true" to cd "Somatic"
      send PurgeScaledStuffFromZoomPalette to cd "Somatic" --just in case the scaled pain spots don't want to go away...
   end if
   
   send QuicklyHidePSPropsPaletteAndDeselectCurrentPainSpot to cd "Somatic"
   --hide grc "PSHighlight" of cd "Somatic"
   --put empty into gCurrentPainSpot
   
   put 1 into gPageCount --we start off with only one page
   put 1 into gCurrentPage --and that's the one that we're looking at of course
   put "FrontAndBack" into gCurrentView
   DrawZoomViewHighlightRect "FrontAndBack"
   put empty into gToMove
   put false into gKeyboardOnShow
   hide image "gremlin" of cd "Somatic"
   
   --empty out the current stuff stored in the global variables
   delete global gPainSpotPageArr
   delete global gDrawingPageArr
   delete global gPageEmotionArr
   delete global gPageDescArr
   
   delete global gMostRecentScreenShotArr
   
   put empty into gCurrentEmotion
   hide image "Emotion" of cd "Somatic"
end ResetSomaticCard


on lcVCSExport
   ResetSomaticCard
end lcVCSExport


on ResetEPStatus
   put "1,2,3,4,5,6,7,8,9" into gEmotPaletteStatus
end ResetEPStatus


on SetupPersonImages
   local tTheBodyViewFrontImage, tTheBodyViewBackImage,tTheEmotLocsFile, tTheEmotLocs,tZoomPaletteFandBImage
   local tTheEmotionsCardImage, tTheEmotionsCardEmotLocsFile
   if gUseVandPImages is true then
      put "./graphics/newPeople/xxxx v&p front.png" into tTheBodyViewFrontImage
      put tTheBodyViewFrontImage into tTheEmotLocsFile
      put "./graphics/newPeople/xxxx v&p back.png" into tTheBodyViewBackImage
   else
      put "./graphics/newPeople/xxxx clothed front.png" into tTheBodyViewFrontImage
      put tTheBodyViewFrontImage into tTheEmotLocsFile
      put "./graphics/newPeople/xxxx clothed back.png" into tTheBodyViewBackImage
   end if
   
   --the Emotions card image is always clothed.
   put "./graphics/newPeople/xxxx clothed front.png" into tTheEmotionsCardImage
   put tTheEmotionsCardImage into tTheEmotionsCardEmotLocsFile
   
   
   put "./graphics/frontandback/xxxx.png" into tZoomPaletteFandBImage
   
   set the itemdelimiter to "."
   put "txt" into item -1 of tTheEmotLocsFile --put a ".txt" on the end for the location information file
   put "txt" into item -1 of tTheEmotionsCardEmotLocsFile --put a ".txt" on the end for the location information file
   
   
   replace "xxxx" with gGender in tTheBodyViewFrontImage
   replace "xxxx" with gGender in tTheEmotLocsFile
   replace "xxxx" with gGender in tTheBodyViewBackImage
   
   replace "xxxx" with gGender in tTheEmotionsCardImage
   replace "xxxx" with gGender in tTheEmotionsCardEmotLocsFile
   
   replace "xxxx" with gGender in tZoomPaletteFandBImage
   
   
   set the filename of image "person" of cd "emotions"  to tTheEmotionsCardImage
   set the filename of image "front" of cd "Somatic"  to tTheBodyViewFrontImage
   set the filename of image "back" of cd "Somatic"  to tTheBodyViewBackImage
   
   set the filename of image "FrontAndBack" of grp "ZoomPalette" of cd "Somatic" to tZoomPaletteFandBImage
   set the loc of img "FrontAndBack" of grp "ZoomPalette" of cd "Somatic" to the loc of btn "FandBAlign" of grp "ZoomPalette" of cd "Somatic" 
   
   if gCurrentView is "FrontAndBack" then
      DrawZoomViewHighlightRect gCurrentView 
   end if
   if there is a file tTheEmotLocsFile then
      put URL ("file:" & tTheEmotLocsFile) into tTheEmotLocs
      set the cpEmotLocOffsets of image "front" of cd "Somatic" to tTheEmotLocs
   end if
   
   if there is a file tTheEmotionsCardEmotLocsFile then
      put URL ("file:" & tTheEmotionsCardEmotLocsFile) into tTheEmotLocs
      set the cpEmotLocOffsets of image "person" of cd "emotions" to tTheEmotLocs
   end if
   
end SetupPersonImages


command DrawZoomViewHighlightRect pWhichImage
   set the width of grc "ZoomViewHighlight" of cd "Somatic" to (the width of img pWhichImage of cd "Somatic" + 6)
   set the height of grc "ZoomViewHighlight" of cd "Somatic" to (the height of img pWhichImage of cd "Somatic" + 6)
   set the loc of grc "ZoomViewHighlight" of cd "Somatic" to the loc of img pWhichImage of cd "Somatic"
end DrawZoomViewHighlightRect


on switchGender
   if gGender is "boy" then
      put "girl" into gGender
   else
      put "boy" into gGender
   end if
end switchGender

command initEmotPalLocation
   put (the width of this stack) div 2 into lHoriz
   put 8 into lVert --was 15. Now we want to appear below the page label and navigation controls
   set the loc of btn "facealign" to lHoriz,lVert
end initEmotPalLocation


command DrawEmotionPalette
   put the width of group "face1" into lWidth
   put round(((the number of items of gEmotPaletteStatus) * lWidth) / 2) into lHalfWidth
   put (item 1 of the loc of btn "facealign") - lHalfWidth into lLeft
   put item 2 of the loc of btn "facealign" into lTop
   repeat for each item theface in gEmotPaletteStatus
      set the topLeft of group ("face" & theface) to lLeft,lTop
      show grp ("face" & theface)
      put "label" & theface into LabelName
      if there is a fld LabelName then
         set the top of fld LabelName to the bottom of group ("face" & theface) + 1
         set the width of fld LabelName to the width of group ("face" & theface)
         set the left of fld LabelName to the left of group ("face" & theface)
         show fld LabelName
         if gEmotionLabelsArr[theface] is not empty then
            put gEmotionLabelsArr[theface] into fld LabelName
         else
            put empty into fld LabelName
         end if
      end if
      add lWidth to lLeft
   end repeat
   wait for 0 seconds with messages
   repeat for each item theface in gEmotPaletteStatus
      set the currentLoc of group ("face" & theface) to the loc of group ("face" & theface)
      if there is a fld ("label" & theface) then
         set the currentLoc of field ("label" & theface) to the loc of field ("label" & theface)
      end if
   end repeat
end DrawEmotionPalette


command DrawPerson
   constant cBodyVertOffset = 160
   set lockScreen to true
   set the loc of image "person" to the loc of btn "facealign"
   set the top of image "person" to the bottom of btn "facealign" + cBodyVertOffset
   set lockScreen to false
end DrawPerson



--calculate an offset for a painspot from the body view on which they're placed.
--uses the cpAttachedTo property to decide which body image view shoud be used to calculate the offset.
function CalculateImgOffset pWhichButton
   put the cpAttachedTo of btn pWhichButton into lBodyView
   if lBodyView is not among the items of "Front,Back" then -- we are dealing with a single zoomed image view, not front and back
      put "ZoomImage" into lBodyView
   end if
   put the loc of image lBodyView into lLoc
   put the loc of  btn pWhichButton into lBtn
   put item 1 of lBtn - item 1 of lLoc into lHOffset
   put item 2 of lBtn - item 2 of lLoc into lVOffset
   return lHOffset,lVOffset
end CalculateImgOffset



--calculate an offset for a drawing from the body view on which they're placed.
--uses the cpAttachedTo property to decide which body image view shoud be used to calculate the offset.
function CalculateDrawingOffset pWhichDrawing
   put the cpAttachedTo of grc pWhichDrawing into lBodyView
   if lBodyView is not among the items of "Front,Back" then
      put "ZoomImage" into lBodyView
   end if
   put the loc of image lBodyView into lLoc
   put the loc of  grc pWhichDrawing into lBtn
   put item 1 of lBtn - item 1 of lLoc into lHOffset
   put item 2 of lBtn - item 2 of lLoc into lVOffset
   return lHOffset,lVOffset
end CalculateDrawingOffset



on TouchRelease
   put empty into gToMove
   CheckAndClearTextTouchInProgress
   put empty into gBackdropTouchDown
end TouchRelease



on TextTouch pWhat, pTheID
   PJdebug "we're handling the textTouch"
   if gKeyboardOnShow is false then -- text touches not allowed while we've got the keyboard up.
      if gTouchToEditText is true then --we are in immediate text field edit mode, not "hold to edit"
         put pWhat into gTextEditTarget
         set the lockText of fld gTextEditTarget to false
         send StartTheTextEdit to this stack in 2 ticks
      else
         CheckAndClearTextTouchInProgress
         put pWhat,pTheID into gTextTouchInProgress
         put the mouseLoc into gInitialTextTouchLoc
         send CheckStillTouching && gInitialTextTouchLoc & "," & pWhat to me in 100 milliseconds --0.1 second - was 1.1 seconds hold to go into edit mode
         PJdebug "sending CheckStillTouching"
         HighlighTextEditField pWhat
      end if
   end if
end TextTouch


on CheckAndClearTextTouchInProgress
   if gTextTouchInProgress is not empty then
      unHighLightTextField item 1 of gTextTouchInProgress
      cancelThisMsg "CheckStillTouching" 
      put empty into gTextTouchInProgress --do it now because we might be in the middle of something later
   end if
end CheckAndClearTextTouchInProgress


on HighlighTextEditField pWhat
   set the savedBackgroundColor of fld pWhat to the backgroundColor of fld pWhat
   set the backgroundColor of fld pWhat to 151,151,151
   set the savedOpaque of fld pWhat to the opaque of fld pWhat
   set the opaque of fld pWhat to true
end HighlighTextEditField


on unHighLightTextField pWhat
   set the backgroundColor of fld pWhat to the savedBackgroundColor of fld pWhat
   set the opaque of fld pWhat to the savedOpaque of fld pWhat
end unHighLightTextField



on CheckStillTouching pHoriz,pVert,pWhat
   if TextTouchStillWithinTargetArea(pHoriz,pVert) and (pWhat is item 1 of gTextTouchInProgress)  then --i.e. we've held down for this long on this same item
      unHighLightTextField pWhat
      put item 1 of gTextTouchInProgress into gTextEditTarget
      set the lockText of fld gTextEditTarget to false
      send StartTheTextEdit to this stack in 2 ticks
   end if
end CheckStillTouching



function TextTouchStillWithinTargetArea pHoriz,pVert
   constant cSlop=8
   local lSlopRect
   put pHoriz - cSlop, pVert - cSlop, pHoriz + cSlop, pVert + cSlop into lSlopRect
   if (the mouseLoc is within lSlopRect) then --i.e. we've held down without moving much
      return true
   else
      return false
   end if  
end TextTouchStillWithinTargetArea



on StartTheTextEdit
   global gTextEditTarget
   set the lockText of fld gTextEditTarget to false
   if gTextEditTarget is "description" then
      put gPageDescArr[gCurrentPage] into fld "Description" --which will empty it if it only contains the default, or refresh it if it doesn't
      send DrawDescription to me in 10 ticks --to get it to move into place ready to edit
   end if
   focus on fld gTextEditTarget
   select after fld gTextEditTarget --some fields seem to put the insertion point in funny places and in iOS with LiveCode field
   --you can't move it forward...
end StartTheTextEdit


on keyboardActivated
   put true into gKeyboardOnShow
end keyboardActivated


on keyboardDeactivated
   put false into gKeyboardOnShow
   if gTextEditTarget is not empty then
      if there is a fld gTextEditTarget then
         set the lockText of fld gTextEditTarget to true
         if gTextEditTarget is "description" then
            put fld "description" into gPageDescArr[gCurrentPage] --and save it
            UpdateDescriptionContents
            send DrawDescription to me in 20 ticks --might have left the card by the time this comes in...
         else
            if gTextEditTarget contains "label" then
               put  gTextEditTarget into lWhichLabel
               delete char 1 to 5 of lWhichLabel --remove the "label" bit and leave us with a number
               put fld gTextEditTarget into gEmotionLabelsArr[lWhichLabel]
            end if
         end if
      end if
      focus on nothing
   end if
end keyboardDeactivated


on UpdateDescriptionContents
   if gPageDescArr[gCurrentPage] is not empty then
      put gPageDescArr[gCurrentPage]  into fld "Description"
   else
      if gPageCount > 1 then
         put "Page" && gCurrentPage && "of" && gPageCount into fld "Description"
      else
         put "Page 1" into fld "Description" --we only have one, no need to say "1 of 1".
      end if
   end if
end UpdateDescriptionContents


command RedrawBackdrop
   set the height of grc "Backdrop" of cd "StartAndSetup" to the height of this stack 
   set the width of grc "Backdrop" of cd "StartAndSetup" to the width of this stack 
   set the topLeft of grc "Backdrop" of cd "StartAndSetup" to 0,0
end RedrawBackdrop


command DrawToolSet
   set the topleft of grp "Toolset" to the topleft of btn "ToolsetTL" 
end DrawToolSet


on faceclick pWhich
   OpenUpFaceAndLabel pWhich
   set the filename of image "DragFace" to the filename of image ("face" & pWhich)
   set the loc of image "DragFace" to the mouseLoc
   set the layer of image "DragFace" to top 
   show image "DragFace"
   put "DragFace" into gToMove
   put pWhich into gCurrentEmotion
   put gCurrentEmotion into gPageEmotionArr[gCurrentPage]
end faceclick



on OpenUpFaceAndLabel pWhich
   constant cNewWidth = 140
   constant cDownOffset = 30
   global gOpenFace
   if the short name of this card is "Emotions" then
      if  gOpenFace <> pWhich then
         if (gOpenface is not empty) then
            CloseUpFaceAndLabel
         end if
         if there is a group ("face" & pWhich) then
            put the currentLoc of group ("face" & pWhich) into lOrigLoc
            put lOrigLoc into lNewLoc
            add cDownOffset to item 2 of lNewLoc
            put the currentLoc of fld ("label" & pWhich) into lFldOrigLoc
            put lFldOrigLoc into lFldNewLoc
            add cDownOffset to item 2 of lFldNewLoc
            set lockmoves to true
            move group ("face" & pWhich) from lOrigLoc to lNewLoc without waiting
            set the width of fld ("label" & pWhich) to cNewWidth
            move field ("label" & pWhich) from lFldOrigLoc to lFldNewLoc without waiting
            set lockmoves to false
            
            put pWhich into gOpenFace
         end if
      end if
   end if
end OpenUpFaceAndLabel



on CloseUpFaceAndLabel
   global gOpenFace
   if there is a group ("face" & gOpenFace) then
      put the currentLoc of group ("face" & gOpenFace) into lOrigLoc
      put the loc of group ("face" & gOpenFace) into lNewLoc
      put the currentLoc of fld ("label" & gOpenFace) into lFldOrigLoc
      put the loc of fld ("label" & gOpenFace) into  lFldNewLoc
      set the width of fld ("label" & gOpenFace) to the width of group ("face" & gOpenFace)
      set lockmoves to true
      move group ("face" & gOpenFace) from lNewLoc to lOrigLoc without waiting
      move field ("label" & gOpenFace) from lFldNewLoc to lFldOrigLoc without waiting
      set lockmoves to false
      put empty into gOpenFace
   end if
end CloseUpFaceAndLabel


on resizeStack
   global gEmotPaletteConfig
   put the short name of the current card into CC
   switch CC
      case "StartAndSetup"
         RedrawBackdrop
         break
      case  "Emotions"
         initEmotPalLocation
         DrawEmotionPalette
         DrawPerson
         break
      case "Somatic"
         initEmotPalLocation
         --         send FancyDrawEmotionPalette && gEmotPaletteConfig to cd "Somatic"
         --         send movestopped to cd "Somatic"
         DrawToolSet
         DrawZoomPalette
         if gCurrentView is "FrontAndBack" or gCurrentView is empty then
            send FancyDrawEmotionPalette && gEmotPaletteConfig to cd "Somatic"
            send movestopped to cd "Somatic"
            DrawBodyViews
         else
            DrawBodyViews "Zoomed"
         end if
         
         PlaceGearAndPrefsPalette
         PlaceAnnotationFields
         DrawDescription
         DrawNavigationControls
         DrawAllPainSpots
         DrawAllDrawings
         HandleToolPaletteStatus
         break
   end switch
end resizeStack


command PlaceGearAndPrefsPalette
   set the loc of grp "gear" of cd "Somatic" to (the width of this stack - 38,24)
   set the top of grp "SomaticPrefs" of cd "Somatic" to the bottom of grp "gear" of cd "Somatic" - 20
   set the right of grp "SomaticPrefs" of cd "Somatic" to the width of this stack - 5
end PlaceGearAndPrefsPalette


command DrawZoomPalette
   set the loc of grp "ZoomPalette" of cd "Somatic" to (the width of this stack) - ((the width of grp "ZoomPalette" of cd "Somatic") div 2) -6,\
   (((the height of this stack) div  2) + 20)
   if gShowZoomPalette is true then
      show grp "ZoomPalette" of cd "Somatic"
   else
      hide grp "ZoomPalette" of cd "Somatic"
   end if
end DrawZoomPalette


command DrawBodyViews pWhichView
   constant cRHSSpacer=280 
   constant cSingleViewROffset = 0
   --this section no longer needed - the images are setup from the front card (and on any click of the gender chooser).
   --   set the filename of image "front" of card "Somatic" to the filename of image (gGender & "front" )of cd "GenderInfo"
   --   set the filename of image "back" of card "Somatic" to the filename of image (gGender & "back" )of cd "GenderInfo"
   --   set the cpEmotLoc of image "front" of card "Somatic" to the cpEmotLoc of image (gGender & "front" )of cd "GenderInfo"
   
   put the right of grp "Toolset" of cd "Somatic" into tLHSEdge
   put (the width of this stack - (tLHSEdge + the width of grp "ZoomPalette" of cd "Somatic")) div 4 into l1 --width of 1/4 of useful area
   put ((the height of this stack) div  2) + 20 into l2 --was 40 --vertical "centre" of useful area
   put (the width of image "front" of cd "Somatic") div 2 into lBVOffset
   
   put tLHSEdge + ((the width of this stack - (tLHSEdge + the width of grp "ZoomPalette" of cd "Somatic")) div 2) into l3 --middle of useful area 
   
   
   if (pWhichView is not "Zoomed") or (pWhichView is empty) then
      hide image "ZoomImage" of cd "Somatic"
      
      --setup the standard width to be used to scale the mini drawings and painspots.
      set the loc of image "front" of cd "Somatic" to l1 +tLHSEdge ,l2
      set the loc of image "back" of cd "Somatic" to ((3 *  l1)  + tLHSEdge),l2 --screen divided into 3 parts. Use the edges
      put ((the right of img "back" of cd "Somatic") - (the left of img "front" of cd "Somatic")) into gViewWidthsArr["FrontAndBack"]
      
      if gShowTwoViews is true then --if we're using two up view then all we now need to do is show the images.
         --         set the loc of image "front" of cd "Somatic" to l1 +tLHSEdge ,l2
         --         set the loc of image "back" of cd "Somatic" to ((3 *  l1)  + tLHSEdge),l2 --screen divided into 3 parts. Use the edges
         show image "front" of cd "Somatic"
         show image "back" of cd "Somatic"
         hide image "rotate" of cd "Somatic"
         
         
         --         put ((the right of img "back" of cd "Somatic") - (the left of img "front" of cd "Somatic")) into gViewWidthsArr["FrontAndBack"]
      else
         set the loc of image "front" of cd "Somatic" to l1 +tLHSEdge + cSingleViewROffset ,l2
         set the loc of image "back" of cd "Somatic" to l1 +tLHSEdge + cSingleViewROffset ,l2 --screen divided into 3 parts. Use the edges
         if gShowWhichSingleBodyView is "front" then
            hide image "back" of cd "Somatic"
            show image "front" of cd "Somatic"
         else
            hide image "front" of cd "Somatic"
            show image "back" of cd "Somatic"
         end if
         set the loc of image "rotate" of cd "Somatic" to (item 1 of the loc of image "front" of cd "Somatic"),(the bottom of image "front" of cd "Somatic") + 40
         show image "rotate" of cd "Somatic"
      end if
      --figure out which is the biggest of the images and then add a bit of slop as well
      set the width of grc "VisEffectR" of cd "Somatic" to max(the width of image "front" of cd "Somatic",the width of image "back" of cd "Somatic") + 80
      set the height of grc "VisEffectR" of cd "Somatic" to max(the height of image "front" of cd "Somatic",the height of image "back" of cd "Somatic") + 40
      set the loc of grc "VisEffectR" of cd "Somatic" to the loc of image "front" of cd "Somatic"
      set the rect of grc "DrawLimit" of cd "Somatic" to the right of group "Toolset" of cd "Somatic" + 4, the top of image "front" of cd "Somatic" - 50, \
            the left of grp "ZoomPalette" of cd "Somatic" - 4, the bottom of image "front" of cd "Somatic" + 20   
   else
      hide image "front" of cd "Somatic"
      hide image "back" of cd "Somatic"
      hide image "rotate" of cd "Somatic"
      set the loc of image "ZoomImage" of cd "Somatic" to l3,l2
      
      set the rect of grc "DrawLimit" of cd "Somatic" to the right of group "Toolset" of cd "Somatic" + 4, the top of image "ZoomImage" of cd "Somatic" - 10, \
            the left of grp "ZoomPalette" of cd "Somatic" - 4, the bottom of image "ZoomImage" of cd "Somatic" + 10   
      
      put the width of image "ZoomImage" of cd "Somatic" into gViewWidthsArr[gCurrentView]
      show image "ZoomImage" of cd "Somatic"
   end if
   DrawLRGuidance
end DrawBodyViews


command DrawLRGuidance
   if gShowLRGuidance is true then
      switch gCurrentView
         case "FrontAndBack"
            if the visible of img "Front" of cd "Somatic" is true then
               show grp "RightAndLeft" of cd "Somatic"
            else
               hide grp "RightAndLeft" of cd "Somatic"
            end if
            if the visible of img "Back" of cd "Somatic" is true then
               show grp "LeftAndRight" of cd "Somatic"
            else
               hide grp "LeftAndRight" of cd "Somatic"
            end if
            break
            
         case "hands"
         case "feet"
         case "head_back"
            show grp "LeftAndRight" of cd "Somatic"
            hide grp "RightAndLeft" of cd "Somatic"
            break
            
         case "head_front"
            hide grp "LeftAndRight" of cd "Somatic"
            show grp "RightAndLeft" of cd "Somatic"
            break
      end switch
   else
      hide grp "LeftAndRight" of cd "Somatic"
      hide grp "RightAndLeft" of cd "Somatic"
   end if
end DrawLRGuidance


command PlaceLRGuidance
   switch gCurrentView
      case "FrontAndBack"
         if gShowTwoViews is false then 
            put -6 into tVertOffset
         else
            put 10 into tVertOffset
         end if
         set the loc of grp "RightAndLeft" of cd "Somatic" to (item 1 of the loc of img "Front" of cd "Somatic"), \
               (item 2 of the loc of img "Front" of cd "Somatic") + tVertOffset
         set the loc of grp "LeftAndRight" of cd "Somatic" to (item 1 of the loc of img "Back" of cd "Somatic"), \
               (item 2 of the loc of img "Back" of cd "Somatic") + tVertOffset
         break
      case "hands"
      case "feet"
      case "head_back"
         set the loc of grp "LeftAndRight" of cd "Somatic" to (item 1 of the loc of img "ZoomImage" of cd "Somatic"), \
               (item 2 of the loc of img "ZoomImage" of cd "Somatic") + 10
         break
         
      case "head_front"
         set the loc of grp "RightAndLeft" of cd "Somatic" to (item 1 of the loc of img "ZoomImage" of cd "Somatic"), \
               (item 2 of the loc of img "ZoomImage" of cd "Somatic") + 10
         break
   end switch
end PlaceLRGuidance


command PlaceAnnotationFields
   set the left of field "InViewAnnotation1" to the left of grc "DrawLimit"
   set the height of field "InViewAnnotation1" to (the top of img  "front") - 3
   set the bottom of field "InViewAnnotation1" to (the top of img "front") - 3
   set the left of field "InViewAnnotation2" to the right of field "InViewAnnotation1"
   set the height of field "InViewAnnotation2" to (the top of img  "front") - 3
   set the bottom of field "InViewAnnotation2" to (the top of img "front") - 3
end PlaceAnnotationFields


command DrawDescription
   --   if gKeyboardOnShow is not true then
   --      set the loc of fld "Description" to ((the width of this stack) div 2),(the bottom of image "front") + 60 ---half it's height of 20 + 10
   --   else
   --      set the loc of fld "Description" to ((the width of this stack) div 2),((the height of this stack) div 2) 
   --   end if
   set the loc of fld "description" of cd "Somatic" to ((the width of this stack) div 2) - 10, 25
end DrawDescription


on DrawNavigationControls
   set lockscreen to true
   set the loc of grp "PreviousPage" to the loc of  fld "Description"
   set the left of grp "PreviousPage" to the right of  fld "Description" + 8
   set the loc of grp "NewPage" to the loc of  fld "Description" 
   set the right of grp "NewPage" to the right of  fld "Description" 
   set the loc of grp "NextPage" to the loc of  fld "Description"
   set the left of grp "NextPage" to the right of grp "PreviousPage" + 8
   
   if gCurrentPage = 1 then
      SetNavigationButtonStatus "Disable","PreviousPage"
   else
      SetNavigationButtonStatus "Enable","PreviousPage"
   end if
   
   if gCurrentPage = gPageCount then
      SetNavigationButtonStatus "Disable","NextPage"
   else
      SetNavigationButtonStatus "Enable","NextPage"
   end if
   
   set lockscreen to false
end DrawNavigationControls


on SetNavigationButtonStatus pStatus,pWhichNavBtn
   if pStatus contains "disable" then
      hide grp pWhichNavBtn
   else
      show grp pWhichNavBtn
   end if
end SetNavigationButtonStatus




gShowTwoViews
gShowWhichSingleBodyView

command DrawAllPainSpots
   --this does not draw new buttons, it simply re-displays the ones currently on the card - it's called specially if we change the 2-up to 1-up
   --it uses the buttons on the card in order to retrieve a list of objects to handle.
   repeat with looper=1 to the number of buttons of cd "Somatic"
      if the cpAttachedTo of btn looper of cd "Somatic" is not empty then --it is a dragged painspot button (no other buttons have this property).
         put the cpAttachedTo of btn looper of cd "Somatic" into lAttachedTo  --what view was it attached to?
         put the cpLocOffset of btn looper of cd "Somatic" into lPSOffset --what is the image offset
         --  PJdebug lAttachedTo && lPSOffset
         --if were showing two views, or we're showing one view and it's the correct one, or we're showing a zoom view for this type
         if  ((gShowTwoViews is true) or ((gShowTwoViews is false) and (lAttachedTo is gShowWhichSingleBodyView))) or\
         (lAttachedTo is the cpViewImage of img "ZoomImage")  then
            
            if lAttachedTo is not among the items of "back,front" then
               put "ZoomImage" into lAttachedTo
            end if
            
            put the loc of image lAttachedTo of cd "Somatic" into lLoc
            put (item 1 of lLoc) + (item 1 of lPSOffset) into lHoriz
            put (item 2 of lLoc) + (item 2 of lPSOffset) into lVert
            set the loc of btn looper of cd "Somatic" to lHoriz,lVert
            show btn looper of cd "Somatic"
         else
            hide btn looper of cd "Somatic"
         end if
      end if
   end repeat
end DrawAllPainSpots


command DrawAllDrawings
   --this does not draw new graphics, it simply re-displays the ones currently on the card - it's called specially if we change the 2-up to 1-up
   --it does not get the info about location etc. from the gDrawingPageArr global - just the names of the objects.
   put the keys of gDrawingPageArr[gCurrentPage][gCurrentView] into lDrawingList --we do not get the info from the array, we use the info built into the currently drawn stuff
   repeat for each line theDrawing in lDrawingList
      if the cpAttachedTo of grc theDrawing of cd "Somatic" is not empty then --we should have every drawing attached to a body view - ignore it if not
         put the cpAttachedTo of grc theDrawing of cd "Somatic" into lAttachedTo  --what view was it attached to?
         put the cpLocOffset of grc theDrawing of cd "Somatic" into lPSOffset --what is the image offset
         --if were showing two views, or we're showing one view and it's the correct one, or we're showing a zoom view for this type
         if  ((gShowTwoViews is true) or ((gShowTwoViews is false) and (lAttachedTo is gShowWhichSingleBodyView))) or\
         (lAttachedTo is the cpViewImage of img "ZoomImage")  then
            --if (there is an image lAttachedTo of cd "Somatic") and (the visible of image lAttachedTo of cd "Somatic" is true) then
            
            if lAttachedTo is not among the items of "back,front" then
               put "ZoomImage" into lAttachedTo
            end if
            
            put the loc of image lAttachedTo of cd "Somatic" into lLoc
            put (item 1 of lLoc) + (item 1 of lPSOffset) into lHoriz
            put (item 2 of lLoc) + (item 2 of lPSOffset) into lVert
            set the loc of grc theDrawing of cd "Somatic" to lHoriz,lVert
            show grc theDrawing of cd "Somatic"
         else
            hide grc theDrawing of cd "Somatic"
         end if
      end if
   end repeat
end DrawAllDrawings



command HandleToolPaletteStatus
   global gToolPaletteStatus
   if gToolPaletteStatus is "drawing" then
      FadeOutPainSpots
      FadeInDrawings   
   else
      if gToolPaletteStatus is "painspots" then
         FadeOutDrawings
         FadeInPainSpots
      else --must be "moving" mode...
         SetDrawingsVisualStatus "DropShadow"
         SetPainSpotsVisualStatus "DropShadow"
      end if
   end if
end HandleToolPaletteStatus


command FadeInDrawings
   SetDrawingsVisualStatus "fullOn"
end FadeInDrawings


command FadeOutDrawings
   SetDrawingsVisualStatus "faded"
end FadeOutDrawings


command FadeInDrawingsWithDropShadow
   SetDrawingsVisualStatus "DropShadow"
end FadeInDrawingsWithDropShadow


command FadeInPainSpotsWithDropShadow
   SetPainSpotsVisualStatus "DropShadow"
end FadeInPainSpotsWithDropShadow


command FadeInPainSpots
   SetPainSpotsVisualStatus "fullOn"
end FadeInPainSpots


command FadeOutPainSpots
   SetPainSpotsVisualStatus "faded"
end FadeOutPainSpots


command SetPainSpotsVisualStatus pWhat
   set lockscreen to true
   if pWhat is "faded" then --if it is faded then draw it with a high blendlevel
      put cFaded into tTheStatus
   else
      put cFullOn into tTheStatus
   end if
   put the keys of gPainSpotPageArr[gCurrentPage][gCurrentView] into lButtonList
   repeat for each line theButton in lButtonList
      if there is a btn theButton of cd "Somatic" then
         set the blendlevel of btn theButton of cd "Somatic" to tTheStatus
         if pWhat is "DropShadow" then
            SetDropShadow "btn" && theButton && "of cd" && quote & "Somatic" & quote
         else
            ClearDropShadow "btn" && theButton && "of cd" && quote & "Somatic" & quote
         end if
      end if
   end repeat
   set lockscreen to false
end SetPainSpotsVisualStatus


command SetDrawingsVisualStatus pWhat
   set lockscreen to true
   if pWhat is "faded" then --if it's faded then fade it out
      put cFaded into tTheStatus
   else --otherwise draw it in full
      put cFullOn into tTheStatus
   end if
   
   put the keys of gDrawingPageArr[gCurrentPage][gCurrentView] into lDrawingList
   repeat for each line theDrawing in lDrawingList
      if there is a grc theDrawing of cd "Somatic" then
         set the blendlevel of grc theDrawing of cd "Somatic" to tTheStatus
         if pWhat is "DropShadow" then
            SetDropShadow "grc" && theDrawing && "of cd" && quote & "Somatic" & quote
         else
            ClearDropShadow "grc" && theDrawing && "of cd" && quote & "Somatic" & quote
         end if
      end if
   end repeat
   set lockscreen to false
end SetDrawingsVisualStatus


on SetDropShadow pWhat
   if there is a pWhat then
      set the dropshadow["color"] of pWhat to 118,118,118
      set the dropshadow["blendmode"] of pWhat to "normal"
      set the dropshadow["opacity"] of pWhat to 191
      set the dropshadow["filter"] of pWhat to "box3pass"
      set the dropshadow["spread"] of pWhat to 0
      set the dropshadow["Size"] of pWhat to 5
      set the dropshadow["Distance"] of pWhat to 10 -- was 5
      set the dropshadow["Angle"] of pWhat to 60
      set the dropshadow["knockout"] of pWhat to true
   end if
end SetDropShadow


on ClearDropShadow pWhat
   if there is a pWhat then
      set the dropshadow of pWhat to 0
   end if
end ClearDropShadow


on ExplodeAnObject
   put "./graphics/smoke plume/smoke_plume_00" into fname1
   put ".png" into fname2
   set the layer of image "explode" to top
   repeat with looper=1 to 10
      put fname1 & format("%02d",looper) & fname2 into theFilename
      set the filename of image "explode" to theFilename
      show image "explode"
      wait for 2 ticks with messages
   end repeat
   hide image "explode"
end ExplodeAnObject


on SetupNewSession
   put the long date && the long time into lFolderName
   replace ":" with "." in lFolderName
   replace "/" with "-" in lFolderName --just in case we have any present
   put specialfolderpath("Documents") &"/" & lFolderName into gSessionFolder
   create folder gSessionFolder
end SetupNewSession



on cancelThisMsg tMsg
   put the pendingMessages into tPendingMsgs
   if tMsg is in tPendingMsgs then
      repeat for each line x in tPendingMsgs
         if tMsg is in x then cancel item 1 of x
      end REPEAT
   end if
end cancelThisMsg


function getHexRandomNumber
   get random(15)
   get baseConvert(it,10,16)
   return it
end getHexRandomNumber


function PJUUID
   -- Version 4 of RFC 4122 (pseudo random)
   repeat 8 times
      put getHexRandomNumber() after tUUID
   end repeat
   put "-" after tUUID
   repeat 4 times
      put getHexRandomNumber() after tUUID
   end repeat
   put "-4" after tUUID
   repeat 3 times
      put getHexRandomNumber() after tUUID
   end repeat
   put "-" & any char of "89AB" after tUUID
   repeat 3 times
      put getHexRandomNumber() after tUUID
   end repeat
   put "-" after tUUID
   repeat 12 times
      put getHexRandomNumber() after tUUID
   end repeat
   return tUUID
end PJUUID


function mob
   return (the environment is "mobile")
end mob



on ClearAllInMemoryDataAndSetupNewSession pReallyCreateANewSession
   global gCurrentEmotion
   global gEmotionLabelsArr
   put empty into gCurrentEmotion
   delete global gEmotionLabelsArr
   hide image "Emotion" of cd "emotions"
   ResetSomaticCard
   if pReallyCreateANewSession is true then
      SetupNewSession
   end if
end ClearAllInMemoryDataAndSetupNewSession


command CheckForFirstRun
   put specialfolderpath("cache") & "/" & cFirstRunFlagFile into lFileName
   if there is no file lFileName then
      put PJUUID() into gUUID 
      put gUUID into URL ("file://" & lFileName)
   else
      put URL ("file://" & lFileName) into gUUID
   end if
end CheckForFirstRun



on Shutdown --save stuff here
   -- we should check to see if we're not on the scales card so don't need to save anything
   --put "The current card is:" &&  (the name of the current card)
   if the name of the current card contains "Somatic" then
      --this is the only time we probably can't redraw the screen in the case of a one-up view - sorry
      TakeScreenShot
      SavePageData true
   end if
end Shutdown


--takes a screenshot and saves it to a specific file who's name is placed in the global gMostRecentScreenShotArr
--Note - for body view screenshots there may be two (front and back) if the single body view mode is selected.
--This adds a bit of complexity - there are two screen shots but only one set of data.
on TakeScreenShot
   global gMostRecentScreenShotArr
   iphoneActivityIndicatorStart "whiteLarge",26,26
   wait for 0 ticks with messages
   if (gCurrentView is "FrontAndBack") and (gShowTwoViews is false) then
      put "-" & gShowWhichSingleBodyView into tSuffix
   else
      put empty into tSuffix
   end if
   --GetCurrentPageAndViewFileName can now return extended filenames for body view images (bot not data files)
   put GetCurrentPageAndViewFileName(".png",true) into gMostRecentScreenShotArr[gCurrentPage][gCurrentView & tSuffix]
   
   --   PJdebug  PrettyPaths(gMostRecentScreenShotArr[gCurrentPage][gCurrentView & tSuffix])
   
   export snapshot from rectangle (the rect of grc "DrawLimit" of cd "Somatic") to \
         file gMostRecentScreenShotArr[gCurrentPage][gCurrentView & tSuffix] as png
   iphoneActivityIndicatorStop
end TakeScreenShot


command AnnotateAllItems 
   global gAnnotationsArr
   local tButtonList, tButtonCounter, tDrawingList, tDrawingCounter
   put the keys of gPainSpotPageArr[gCurrentPage][gCurrentView] into tButtonList
   if the number of lines of tButtonList > 0 then
      put 0 into tButtonCounter
      repeat for each line theButton in tButtonList
         add 1 to tButtonCounter
         clone grp "TemplatePSLabel"
         put ("AnnotatedPS" & tButtonCounter) into tTheName
         set the name of it to tTheName
         put tButtonCounter into fld "Num" of grp tTheName
         set the loc of grp tTheName to the loc of btn theButton --has to be the centre - the numbers are too detached otherwise
         show grp tTheName
         put (the long id of grp tTheName) into gAnnotationsArr[tButtonCounter]
      end repeat
   end if
   
   put the keys of gDrawingPageArr[gCurrentPage][gCurrentView] into tDrawingList
   put the number of lines of tDrawingList into tNumDrawings
   if tNumDrawings > 0 then
      set the itemdelimiter to "|"
      put 0 into tDrawingCounter
      repeat for each line theDrawing in tDrawingList
         add 1 to tDrawingCounter
         clone grp "TemplateDrwLabel"
         put ("AnnotatedDrw" & tDrawingCounter) into tTheName
         set the name of it to tTheName
         put tDrawingCounter into fld "Num" of grp tTheName
         put line 1 of the points of grc theDrawing into tTheLoc
         set the loc of grp tTheName to tTheLoc --the topleft of grc theDrawing
         show grp tTheName
         put (the long id of grp tTheName) into gAnnotationsArr[tButtonCounter + tDrawingCounter]
      end repeat
   end if
end AnnotateAllItems


command DeleteAllAnnotations
   global gAnnotationsArr
   put the keys of gAnnotationsArr into tTheItems
   repeat for each line tTheItem in tTheItems
      put gAnnotationsArr[tTheItem] into tObjectOfInterest
      if there is a tObjectOfInterest then
         delete tObjectOfInterest
      end if
   end repeat
end DeleteAllAnnotations


function MakeNiceHTML pWhat, pSaveAsHTML
   if (pSaveAsHTML is true) and (pWhat is empty) then
      return "&nbsp;"
   else
      return pWhat
   end if
end MakeNiceHTML


function GenerateCAPSHeader pSaveAsHTML
   global gCAPS_ID
   local tOutput, 
   if pSaveAsHTML is true then
      put "<table border='1'><tr><th>Session ID</th></tr>" & return into tOutput
      put "<tr><td>" & MakeNiceHTML(gCAPS_ID,pSaveAsHTML) & "</td></tr></table><br/><br/>" & return after tOutput
   else
      put "CAPS ID" & return into tOutput
      put gCAPS_ID & return & return after tOutput
   end if
   return tOutput
end GenerateCAPSHeader


function GenerateEmotionsData pSaveAsHTML
   local tTempOutput, tOutput
   if pSaveAsHTML is true then
      put "Emotion Labels:<br/>" & return into tOutput
   else
      put "Emotion Labels:" & return into tOutput
   end if
   put empty into tTempOutput
   repeat with looper=1 to cNumEmotions
      put looper & "," after tTempOutput
   end repeat
   delete char -1 of tTempOutput
   --
   --heading row (emotion numbers)
   if pSaveAsHTML is true then
      replace "," with "</th><th>" in tTempOutput
      put "<table border='1'><tr><th>" before tTempOutput
      put "</th></tr>" after tTempOutput
   end if
   put tTempOutput & return after tOutput
   --
   --data row (emotion names)
   put empty into tTempOutput
   repeat with looper=1 to cNumEmotions
      put MakeNiceHTML(gEmotionLabelsArr[looper],pSaveAsHTML) & "," after tTempOutput
   end repeat
   delete char -1 of tTempOutput
   if pSaveAsHTML is true then
      replace "," with "</td><td>" in tTempOutput
      put "<tr><td>" before tTempOutput
      put "</td></tr></table><br/><br/>" after tTempOutput
   end if
   put tTempOutput & return & " " & return after tOutput
   return tOutput
end GenerateEmotionsData


function GeneratePageHeaderData pSaveAsHTML
   local tDescription, tExtraLF, lOutput
   put gPageDescArr[gCurrentPage] into tDescription
   if pSaveAsHTML is true then
      put "<br/>" into tExtraLF
   else
      put empty into tExtraLF
   end if
   if tDescription contains quote then
      if pSaveAsHTML is true then
         replace quote with "&#34;" in tDescription --use the HTML "
      else
         replace quote with "'" in tDescription --i.e. - replace double-quote with single quote
      end if
   end if
   if tDescription contains comma then --any commas in the description? Double-quote the whole thing.
      if pSaveAsHTML is true then
         --in HTML we can use an entity type to get around this
         replace comma with "&#44;" in tDescription --use HTML ,
      else
         --in csv we need to use a quote
         put quote before tDescription
         put quote after tDescription
      end if
   end if
   
   put "Page:" && gCurrentPage & tExtraLF & return into lOutput
   put "Description:" && MakeNiceHTML(tDescription,pSaveAsHTML) & tExtraLF & return after lOutput
   put "Chosen Emotion:" && MakeNiceHTML(gPageEmotionArr[gCurrentPage],pSaveAsHTML) & tExtraLF & tExtraLF & return after lOutput
   return lOutput
end GeneratePageHeaderData


----The following function handles the complexity involved in dealing with the body views when we have a one-up display
----We have to change the view that we're dealing with to include the front or back so as to record the two separately.
----This will probably cause us grief if we switch between the two, but since it's only used for data output (image etc.) then
----it shouldn't cause a display issue (I hope). At the wortst, you may get a 2-up view and two separate single views.
----of course, if the current view is not the one you're using, then the result of this function for the FrontAndBack view may
----not give the desired result...
--function GetExtendedViewType pWhichView
--   if (pWhichView is "FrontAndBack") and (gShowTwoViews is false) then
--      put "-" & gShowWhichSingleBodyView into tSuffix
--   else
--      put empty into tSuffix
--   end if
--   return (pWhichView & tSuffix)
--end GetExtendedViewType


function GeneratePainSpotData  pWhichView,pSaveAsHTML
   local tButtonList,  tOutput, tTempOutput
   if pWhichView is empty then
      put gCurrentView into pWhichView
   end if
   put the keys of gPainSpotPageArr[gCurrentPage][pWhichView] into tButtonList
   if the number of lines of tButtonList > 0 then
      if pSaveAsHTML is true then
         put "<table border='1'><tr><th>#</th><th>View</th><th>Type</th><th>Throb Rate</th><th>Size</th><th>h:v Offset</th><th>Label</th></tr>" & return into tOutput
      else
         put "#,View,Type,Throb Rate,Size,h:v Offset,Label" & return into tOutput
      end if
      put 0 into tButtonCounter
      repeat for each line theButton in tButtonList
         add 1 to tButtonCounter
         put gPainSpotPageArr[gCurrentPage][pWhichView][theButton] into lButtonData
         set the itemdelimiter to "|"
         put item 1 of lButtonData into lPSType
         put item 2 of lButtonData into lThrobRate
         put item 3 of lButtonData into lTheSize
         put item 4 of lButtonData into lTheLabel
         put item 5 of lButtonData into lAttachedTo
         put item 6 of lButtonData into lTheOffset
         replace "," with ":" in lTheOffset --otherwise our csv data will get out of sync.
         replace "," with ";" in  lTheLabel --ditto
         
         --we can smarten up our output if we know we're looking at feet or hands - we can return left or right
         --note that the hands picure the left hand is on the left. It used to be the case that in the feet picture the left foot was 
         --on the right, but the view has now been rotated to show what the user would see. Now the foot on the left is indeed 
         --the left foot! the LeftOrRight handler has been updated with this information
         if pWhichView is among the items of "feet|hands" then
            put LeftOrRight(pWhichView,lTheOffset) into lAttachedTo
         end if



         put ("#" & tButtonCounter),lAttachedTo,lPSType,lThrobRate,lTheSize,lTheOffset,MakeNiceHTML(lTheLabel,pSaveAsHTML)  into tTempOutput
         if pSaveAsHTML is true then
            replace "," with "</td><td>" in tTempOutput
            put "<tr><td>" before tTempOutput
            put "</td></tr>" after tTempOutput
            
            
         end if
         put tTempOutput & return after tOutput
      end repeat
      if pSaveAsHTML is true then
         put "</table>" & return after tOutput
      end if
   else
      if pSaveAsHTML is true then
         put "Zero<br>" & return after tOutput
      else
         put "Zero" & return after tOutput
      end if
   end if
   return tOutput
end GeneratePainSpotData


function GenerateDrawingData pWhichView, pSaveAsHTML
   if pWhichView is empty then
      put gCurrentView into pWhichView
   end if
   local tDrawingList, tNumDrawings, tDrawingData, tOutput,tTempOutput
   put the keys of gDrawingPageArr[gCurrentPage][pWhichView] into tDrawingList
   put the number of lines of tDrawingList into tNumDrawings
   --   put lNumDrawings && "Drawings recorded on this page." & return after lOutput
   if tNumDrawings > 0 then
      if pSaveAsHTML is true then
         put "<table border='1'><tr><th>#</th><th>F or B</th><th>Thickness</th><th>Colour</th><th>h:v Offset</th></tr>" & return into tOutput
      else
         put "#, F or B,Thickness,Colour,h:v Offset" & return after tOutput
      end if
      set the itemdelimiter to "|"
      put 0 into tDrawingCounter
      repeat for each line theDrawing in tDrawingList
         add 1 to tDrawingCounter
         put gDrawingPageArr[gCurrentPage][pWhichView][theDrawing] into tDrawingData
         --         set the cpAttachedTo of grc theDrawing to item 1 of lDrawingData
         --         set the cpLocOffset of grc theDrawing to item 2 of lDrawingData
         --         set the linesize of grc theDrawing to item 3 of lDrawingData
         --         set the foregroundColor of grc theDrawing to item 4 of lDrawingData
         --         put item 6 of lDrawingData into lThePoints
         put item 1 of tDrawingData into lAttachedTo
         put item 2 of tDrawingData into lTheOffset
         replace "," with ":" in lTheOffset --otherwise our csv data will get out of sync.
         
         --we can smarten up our output if we know we're looking at feet or hands - we can return left or right
         --note that the hands picure the left hand is on the left. The feet picture the left foot is on the right
         if pWhichView is among the items of "feet|hands" then
            put LeftOrRight(pWhichView,lTheOffset) into lAttachedTo
         end if
         
         put item 3 of tDrawingData into lLineSize
         --item 4 is the RGB value of the colour
         put item 5 of tDrawingData into lColourName
         --no need to output the polygon's line segments.
         put ("#" & tDrawingCounter),lAttachedTo,lLineSize, lColourName,lTheOffset into tTempOutput
         if pSaveAsHTML is true then
            replace "," with "</td><td>" in tTempOutput
            put "<tr><td>" before tTempOutput
            put "</td></tr>" after tTempOutput
         end if
         put tTempOutput & return after tOutput
      end repeat
      if pSaveAsHTML is true then
         put "</table>" & return after tOutput
      end if
   else
      if pSaveAsHTML is true then
         put "Zero<br>" & return after tOutput
      else
         put "Zero" & return after tOutput
      end if
   end if
   return tOutput
end GenerateDrawingData


function LeftOrRight pWhichView,pTheLocData
   local tTheLayout, tTheBodyPart
   set the itemdelimiter to ":"
   switch pWhichView 
      case "feet"
         put "left:right" into tTheLayout
         put "foot" into tTheBodyPart
         break
      case "hands"
         put "left:right" into tTheLayout
         put "hand" into tTheBodyPart
         break
   end switch
   
   if item 1 of pTheLocData < 0 then
      return (item 1 of tTheLayout && tTheBodyPart)
   else
      return (item 2 of tTheLayout && tTheBodyPart)
   end if
end LeftOrRight


on SavePageAndViewData pWhichView, pWriteToFile
   global gMostRecentDataFileArr
   local lOutput, lDescription, tSuffix
   put GenerateCAPSHeader() into lOutput
   put GenerateEmotionsData() after lOutput
   
   if pWhichView is empty then
      put gCurrentView into pWhichView
   end if
   
   
   put GeneratePageHeaderData() after lOutput  
   put "Pain Spots:" & return after lOutput
   put GeneratePainSpotData(pWhichView) after lOutput
   put return & "Drawings:" & return after lOutput
   put GenerateDrawingData(pWhichView) after lOutput
   
   put lOutput into fld "Report"
   if pWriteToFile is true then
      put GetCurrentPageAndViewFileName(".csv") into gMostRecentDataFileArr[gCurrentPage][pWhichView]
      put lOutput into URL ("file://" & gMostRecentDataFileArr[gCurrentPage][pWhichView])
   end if
end SavePageAndViewData


function GetCurrentPageAndViewFileName pExt,pIsAView
   global gCAPS_ID
   if (pIsAView is true) and ((gCurrentView is "FrontAndBack") and (gShowTwoViews is false)) then --we need a specific screenshot for a single body view
      return gSessionFolder & "/ID" & SanitizeFileName(gCAPS_ID) && "Page" && gCurrentPage && gCurrentView \
      & "-" & gShowWhichSingleBodyView & pExt
   else
      return gSessionFolder & "/ID" & SanitizeFileName(gCAPS_ID) && "Page" && gCurrentPage && gCurrentView & pExt 
   end if
end GetCurrentPageAndViewFileName


function SanitizeFileName pWhatName
   replace ":" with "." in pWhatName
   return pWhatName
end SanitizeFileName


on DisplayStorageUseStats
   put specialfolderpath("Documents") into lDocsFolder
   put the defaultFolder into oldDF
   set the defaultFolder to lDocsFolder
   put the folders into lFolderList
   filter lFolderList without ".*" --remove any .. folders from the list
   put the number of lines of lFolderList into lNumSessions
   repeat for each line theline in lFolderList
      set the defaultfolder to lDocsFolder & "/" & theline
      put the detailed files into lFileList
      repeat for each line thefileinfo in lFileList
         add item 2 of thefileinfo to lTotalSpaceUsed
      end repeat
   end repeat
   set the defaultFolder to oldDF
   put lTotalSpaceUsed / 1048576 into lMegsUsed 
   put "You currently have" && lNumSessions && "sessions stored for transfer via iTunes, using" && format("%1.2f",lMegsUsed) & "MB." into fld "SessionsInfo" of cd "StartAndSetup"
end DisplayStorageUseStats




on DeleteAllSessionData
   if mob() then
      answer warning "Are you sure you want to delete all the stored data?" with "cancel" or "delete" 
      if it contains "delete" then
         put empty into gSessionFolder --when we are done, we will have no old sessions
         put specialfolderpath("Documents") into lDocsFolder
         put the defaultFolder into oldDF
         set the defaultFolder to lDocsFolder
         put the folders into lFolderList
         repeat for each line theline in lFolderList
            PJDeleteFolder lDocsFolder & "/" & theline
         end repeat
         set the defaultFolder to oldDF
      end if
   end if
end DeleteAllSessionData


on StartNetworkCheck
   iPhoneSetReachabilityTarget cHostServer --reachabilityChanged
end StartNetworkCheck


on reachabilityChanged tMyServer, tReach
   global gNetworkIsConnected
   if ("connection required" is among the items of tReach) or ("intervention required" is among the items of tReach)  then
      put false into gNetworkIsConnected
   end if
   if  "reachable" is among the items of tReach then 
      put true into gNetworkIsConnected
   end if
end reachabilityChanged



command SaveStoredPrefs
   put specialfolderpath("cache") & "/" & cPreferencesFile into lFileName
   put empty into lSavedPrefs
   repeat for each line theKeyName in (the keys of gPrefs)
      put theKeyName & tab & gPrefs[theKeyName] & return after lSavedPrefs
   end repeat
   put lSavedPrefs into URL ("file://" & lFileName) 
end SaveStoredPrefs


command LoadStoredPrefs
   --set defaults in the case where nothing is saved
   put true into gPrefs["ShowZoomPalette"]
   put true into gPrefs["ShowTwoBodyViews"]
   put false into gPrefs["UseVandPImages"]
   put false into gPrefs["EnableGremlinMode"]
   put false into gPrefs["EnableFireObject"]
   put true into gPrefs["EnableNoPainObject"]
   put true into gPrefs["Enable12ColourSwatches"] 
   put false into gPrefs["ShowLRGuidance"]
   
   put false into gPrefs["TouchToEditText"]   
   
   put specialfolderpath("cache") & "/" & cPreferencesFile into lFileName
   if there is a file lFileName then
      put URL ("file://" & lFileName) into lSavedPrefs
      set the itemdelimiter to tab
      repeat for each line theline in lSavedPrefs
         put item 2 of theline into gPrefs[item 1 of theline]
      end repeat
   end if
   put gPrefs["ShowZoomPalette"] into gShowZoomPalette
   put gPrefs["ShowTwoBodyViews"] into gShowTwoViews
   put gPrefs["UseVandPImages"] into gUseVandPImages
   put gPrefs["EnableGremlinMode"] into gEnableGremlinMode
   put gPrefs["EnableFireObject"] into gShowFireObject
   put gPrefs["EnableNoPainObject"] into gShowNoPainObject
   put gPrefs["Enable12ColourSwatches"] into gEnableColourSwatches
   put gPrefs["ShowLRGuidance"] into gShowLRGuidance
   
   put gPrefs["TouchToEditText"] into gTouchToEditText
end LoadStoredPrefs




--deletes a folder that contains one level of files (no other folders)
--the parameter must be the full path to the folder
on PJDeleteFolder pWhichFolder
   put the defaultFolder into oldDF
   set the defaultFolder to pWhichFolder
   put the files into lFileList
   repeat for each line theline in lFileList
      delete file theline
   end repeat
   set the defaultFolder to oldDF
   delete folder pWhichFolder
end PJDeleteFolder



--
-- error handling and debugging stuff here --
--

on PJdebug pMsg
   if there is a fld "debug" then
      put pMsg & return after fld "debug"
   end if
end PJdebug

function PrettyPaths pTheFilePath
   replace "/" with "/ " in pTheFilePath
   return pTheFilePath
end PrettyPaths
 
 
on errorDialog pExecutionError, pParseError
   if the result is not empty then 
      put return & (the result) into tExtra
   end if
   put ("of" && the target) into tTarget
   put item 2 of line 1 of pExecutionError into tErrLineNum
   if (cDebugLevel = "full") and (tErrLineNum > 0) then
      put return & ">" &&  line tErrLineNum of the script of the target  && "<" into theErrorScript
   end if
   answer "A" && (line (item 1 of line 1 of pExecutionError) of the cErrorsList of this stack) && "error occurred on line: " & (item 2 of line 1 of pExecutionError) \
    && tTarget &&  tExtra & theErrorScript
end errorDialog


--on errorDialog pExecutionError, pParseError
--   answer "A" && (line (item 1 of line 1 of pExecutionError) of the cErrorsList of this stack) && "error occurred on line: " & item 2 of line 1 of pExecutionError
--end errorDialog
